Fix the following issues. The issues can be from different files or can overlap on same lines in one file.

In @package.json at line 19, The package "@types/three" is currently listed under dependencies; move it to devDependencies by removing the "@types/three": "^0.182.0" entry from the dependencies section and adding the same entry under devDependencies so type definitions are only installed at build/compile time (ensure the version string "^0.182.0" is preserved).

In @app/components/sections/home/AlchemyHero.tsx around lines 395 - 407, HAIR_STRANDS is using Math.random() during render to set strokeWidth which causes hydration mismatches and instability; replace the inline Math.random() by precomputing stable stroke widths once (e.g., extend the HAIR_STRANDS entries with a strokeWidth property or generate a parallel widths array) and reference that property/array when rendering the <path> in the mapping that sets ref (strandRefs.current[i]) and className "alch-strand"; you can generate the widths with useMemo (or add them to the HAIR_STRANDS constant) so values are deterministic between server and client and do not change on re-renders.

In @app/components/sections/home/AuroraHero.tsx around lines 140 - 148, The useEffect in AuroraHero.tsx currently returns early when window.SplitText or window.CustomEase (or other plugins) are missing but still ends up marking hasAnimated.current and leaving the 6000ms fallback waiting; change the logic so that if any required plugin (SplitText, CustomEase, ScrollTrigger, or gsap) is missing you immediately run the fallback completion path (or call the same routine that the real animation's onComplete uses) and set hasAnimated.current = true there, instead of silently returning; ensure the code paths around useEffect, hasAnimated, and the fallback timeout mirror the successful-animation path so the UI unblocks whether plugins are present or not.

In @app/components/sections/home/CinematicJourneyHero.tsx around lines 227 - 238, Cache DOM element lists outside the scroll callback instead of calling cardsRef.current?.querySelectorAll('.cj-card') (and similarly for '.cj-trust') on every frame: when cardsRef is set or inside the component's layout/effect where you register the scroll animation, query and store the NodeList/array in a local variable or ref (e.g., cachedCardEls) and use that cached collection inside the scroll handler where gsap.set is called; update both the block using cardsRef/current query (the cardEls -> gsap.set loop) and the other similar block (the '.cj-trust' queries) to read from the cached collections and ensure you refresh the cache only when the DOM or cardsRef changes.

In @app/components/sections/home/ConstellationHero.tsx around lines 524 - 525, The code directly accesses dict.home.hero causing a TypeError when dict or dict.home is undefined; update the assignment for h (used by badgeLabels) to safely access nested properties using optional chaining and sensible fallbacks (e.g., const h = dict?.home?.hero ?? {}) and ensure badgeLabels reads from h with defaults (badge values fallback to empty strings or placeholders) so badgeLabels = [h.badge1 ?? '', h.badge2 ?? '', h.badge3 ?? '', h.badge4 ?? ''] thereby preventing runtime errors in ConstellationHero.

In @app/components/sections/home/GlassLayersHero.tsx around lines 505 - 507, The cleanup currently calls ScrollTrigger.getAll().forEach((t) => t.kill()) in the GlassLayersHero effect which indiscriminately kills all global triggers; instead, scope the animations to this component by using a gsap.context (or capture references to created ScrollTrigger instances) inside the GlassLayersHero useEffect and then call ctx.revert() (or kill only the stored triggers) in the returned cleanup function; update the cleanup in the GlassLayersHero useEffect to revert the gsap.context or iterate only over the locally stored trigger refs rather than calling ScrollTrigger.getAll().

In @app/components/sections/home/GlassLayersHero.tsx around lines 796 - 798, The inline @import inside the <style jsx> block in GlassLayersHero is causing render-blocking font requests; remove that @import and instead load the font once (either via Next.js font optimization by importing Cormorant_Garamond from next/font/google and creating a cormorant constant to apply its className, or by adding a single <link> for the Google Font in app/layout.tsx); update GlassLayersHero to remove the @import block and apply the optimized font class (or rely on the global layout link) so the component no longer triggers per-mount font requests.

In @app/components/sections/home/GoldenThreadHero.tsx around lines 219 - 220, The gsap.set call on thread (gsap.set(thread, { drawSVG: '100%' })) is executed immediately during timeline construction instead of at the timeline position; replace it with a timeline set by calling tl.set(thread, { drawSVG: '100%' }, 0.16) so the drawSVG property is applied when the timeline reaches 0.16 (or use tl.set(thread, { drawSVG: '100%' }) at the proper relative position if using labels/relative offsets). Ensure you reference the same timeline variable (tl) and the same target (thread) and remove the standalone gsap.set call.

In @app/components/sections/home/GoldenThreadHero.tsx around lines 323 - 326, The cleanup currently clears the timeout `fallback` but then calls `ScrollTrigger.getAll().forEach((st) => st.kill())`, which indiscriminately kills all ScrollTriggers; instead capture and store the specific ScrollTrigger instance(s) you create in this component (e.g. a local `const myScrollTrigger = ScrollTrigger.create(...)` or push to an array like `const myTriggers: ScrollTrigger[] = [...]`) and in the return cleanup only call `myScrollTrigger.kill()` (or iterate `myTriggers.forEach(t => t.kill())`), leaving other components' ScrollTriggers intact; update the code paths that create triggers in `GoldenThreadHero` to assign to that variable and replace the .getAll() usage.

In @app/components/sections/home/KineticPrismHero.tsx around lines 461 - 463, The cleanup currently calls ScrollTrigger.getAll().forEach(...).kill(), which globally kills triggers; instead, in KineticPrismHero collect the triggers you create (use the return value of ScrollTrigger.create or animator registrations) into a local array (e.g., localTriggers) when setting up animations inside the component (likely in the useEffect that returns the cleanup), and in the cleanup iterate only over localTriggers calling kill() on each; update the useEffect cleanup to reference that localTriggers array rather than ScrollTrigger.getAll() to avoid affecting other components.

In @app/components/sections/home/KineticPrismHero.tsx around lines 724 - 726, The style jsx block in KineticPrismHero.tsx uses an @import for Google Fonts which creates render-blocking requests on every mount; remove the <style jsx> block that imports "Cormorant Garamond" and instead load the font via Next.js font optimization (next/font) or a single global import (e.g., in \_app.tsx or a global CSS file). Update the KineticPrismHero component to rely on the exported font CSS class or global font-family rather than the local <style jsx> import so the component no longer performs runtime @import requests.

In @app/components/sections/home/KineticPrismHero.tsx around lines 56 - 59, The code uses a non-null assertion on the canvas 2D context (canvas.getContext('2d')!) which can throw at runtime; update the KineticPrismHero setup to safely handle a null context by assigning const ctx = canvas.getContext('2d') and then checking if (!ctx) { /_ handle: return early, throw a descriptive error, or fallback _/ } before using ctx, ensuring all subsequent code that references ctx (the canvas drawing logic) only runs when ctx is non-null.

In @app/components/sections/home/LuminousHero.tsx around lines 290 - 293, The current cleanup kills all global ScrollTriggers via ScrollTrigger.getAll().forEach(...), which can break other components; instead remove the global kill call and rely on the gsap.context() cleanup (call ctx.revert() in the returned cleanup) or, if you must manually cleanup, collect and store the triggers created in this component and only call kill() on those references (refer to the fallback timeout variable and any local trigger refs created in the LuminousHero setup to identify which triggers to track).

In @app/components/sections/home/NaturalHarmonyHero.tsx around lines 188 - 199, The gsap.set(...) call attempting to apply morphSVG inside the scroll callback is ineffective because MorphSVGPlugin requires a tween for scrubbing; remove the gsap.set block that references mainPathRef.current, MorphSVGPlugin, morphSVG and SILHOUETTE (and its accompanying comment) and rely solely on the existing ScrollTrigger/tween-based morphing logic that already handles the path morph—this eliminates redundant/no-op code and prevents confusion about scrubbing behavior.

In @app/components/sections/home/RevealHero.tsx around lines 128 - 135, The onStart callback sets a setTimeout to remove blur on doorLeftRef/doorRightRef but does not track or clear that timeout, which can run after unmount; store the timer id (e.g., blurTimeout) when calling setTimeout inside the onStart used by the RevealHero animation, clear it via clearTimeout in the component cleanup (return function of the useEffect that registers the GSAP timeline or in a useEffect that tracks the timer), and ensure you null out the ref/variable after clearing to avoid leaks.

In @app/components/sections/home/RevealHero.tsx around lines 102 - 109, The current effect sets hasAnimated.current = true and returns early when SplitText or CustomEase are missing, leaving content hidden; change the logic so missing plugins do not silently block visibility: check for window.SplitText and window.CustomEase before setting hasAnimated.current, and if either is missing call the existing reveal routine (or directly set the element visible / remove the hidden class) instead of returning; only call gsap.registerPlugin(ScrollTrigger, SplitText, CustomEase) when those plugin symbols exist, and preserve hasAnimated.current semantics so the fallback timer does not need to unhide the content later.

In @app/components/sections/home/SculptorJourneyHero.tsx around lines 6 - 9, The SculptorJourneyHeroProps interface declares dict but the SculptorJourneyHero component only destructures locale; either remove dict from the SculptorJourneyHeroProps interface if unused, or update the component signature to destructure dict as well (e.g., change the component to accept { locale, dict }: SculptorJourneyHeroProps) and then use dict for i18n where appropriate inside SculptorJourneyHero; update all references to the prop shape accordingly to keep types consistent.

In @app/components/sections/home/SilkHero.tsx at line 442, The assignment to h uses direct access (const h = dict.home.hero) which will throw if dict or dict.home is undefined; update the declaration of h (the variable assigned from dict.home.hero) to use optional chaining and a safe fallback (e.g., use dict?.home?.hero with a default like an empty object or sensible defaults) so the component won't crash when dict or dict.home is missing.

In @app/components/sections/home/ThreadHero.tsx around lines 403 - 406, The cleanup currently calls ST.getAll().forEach((t: any) => t.kill()) which destroys all ScrollTrigger instances; instead capture the specific ScrollTrigger instance when you create it (e.g., const heroST = ScrollTrigger.create(...) or const heroST = introSt) and in the return cleanup call only heroST.kill() (and intro.kill() as already present), replacing the ST.getAll() loop so only this component's ScrollTrigger is killed.

In @app/components/sections/home/ThreadHero.tsx around lines 18 - 21, ThreadHeroProps declares a dict: any but the ThreadHero component only destructures locale — either remove dict from the ThreadHeroProps interface and from the component signature, or type dict precisely (e.g., an object with hero: { kicker: string; title: string; subtitle?: string; ctaLabel?: string }) and use it inside the ThreadHero component to replace hardcoded strings (kicker/title/subtitle/cta) with dict.hero.kicker, dict.hero.title, etc.; update all references in the ThreadHero component and export type accordingly so no unused props or any types remain.

In @app/components/sections/home/ThreadHero.tsx around lines 519 - 520, The component ThreadHero currently contains many hardcoded user-facing strings; update the component to use the provided dict prop for i18n by replacing each literal with a dict lookup (e.g., dict.kicker or dict['kicker']) or a translation function exposed on dict; specifically replace the kicker ("JCI-Accredited Aesthetic Surgery in Istanbul"), both CTA texts ("Get Your Free Consultation"), all phase titles/descriptions (the blocks rendered in render/Phase UI inside ThreadHero), the trust badges array entries, and the "Scroll to explore" label with dict keys (add meaningful keys like kicker, cta_primary, phases.[phaseId].title/description, trustBadges, scrollLabel); ensure arrays (trustBadges) and objects (phases) are built from dict values with sensible fallbacks (e.g., default to empty string or existing English text) so rendering won’t break if a key is missing.
